<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Wordle Solver with Next Best Guess</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; text-align: center; background: #fafafa; padding: 14px; }
    .grid { display: grid; grid-template-columns: repeat(5, 56px); gap: 10px; margin: 12px auto; }
    .tile {
      width: 56px; height: 56px; text-align: center;
      border: 2px solid #bbb; text-transform: uppercase;
      font-size: 26px; font-weight: 700;
      border-radius: 6px; padding: 0; box-sizing: border-box;
      caret-color: transparent;
    }
    .grey { background: #cfcfcf; }
    .yellow { background: #f2d36b; }
    .green { background: #9ee29a; }
    #controls { margin-top: 10px; }
    #results, #analysis { margin-top: 16px; max-height: 300px; overflow-y: auto; text-align:left; white-space: pre-wrap; background: #fff; border: 1px solid #eee; padding: 10px; border-radius: 6px; }
    button { padding: 8px 12px; font-size: 15px; margin: 4px; }
    p.hint { font-size: 14px; color: #333; }
  </style>
</head>
<body>
<h1>Wordle Solver</h1>
<p class="hint">Type guesses (auto-advance). Tap a filled tile to cycle colour. Long-press to clear. Filters auto-update when a row is complete.</p>

<div id="board" aria-label="Wordle input board"></div>

<div id="controls">
  <button onclick="resetBoard()">Reset board</button>
</div>

<div id="results"><em>Loading word listâ€¦</em></div>
<div id="analysis"></div>

<script>
const NUM_GUESSES = 6;
const WORD_LEN = 5;
let possibleWords = [];   // answers minus past answers
let allowedWords = [];    // combined allowed guesses + answers for next best guess

/* ---------- Build UI ---------- */
const board = document.getElementById("board");
for (let r = 0; r < NUM_GUESSES; r++) {
  const row = document.createElement("div");
  row.className = "grid";
  row.dataset.row = r;
  for (let c = 0; c < WORD_LEN; c++) {
    const tile = document.createElement("input");
    tile.className = "tile grey";
    tile.maxLength = 1;
    tile.inputMode = "text";
    tile.autocomplete = "off";
    tile.spellcheck = false;
    tile.dataset.state = "grey";
    tile.dataset.col = c;
    tile.dataset.row = r;

    tile.addEventListener("input", () => {
      tile.value = tile.value.toUpperCase();
      if (tile.value && c < WORD_LEN-1) row.children[c+1].focus();
      checkRowAndFilter(row);
    });

    tile.addEventListener("keydown", (e) => {
      if (e.key === "Backspace" && !tile.value && c > 0) row.children[c-1].focus();
      else if (e.key === "Enter") applyFilters();
    });

    tile.addEventListener("click", () => {
      if (tile.value) {
        if (tile.dataset.state === "grey") { tile.dataset.state="yellow"; tile.className="tile yellow"; }
        else if (tile.dataset.state==="yellow") { tile.dataset.state="green"; tile.className="tile green"; }
        else { tile.dataset.state="grey"; tile.className="tile grey"; }
        tile.blur();
        checkRowAndFilter(row);
      }
    });

    let pressTimer;
    tile.addEventListener("touchstart", () => { pressTimer = setTimeout(()=>clearTile(tile,row),500); });
    tile.addEventListener("touchend", () => clearTimeout(pressTimer));
    tile.addEventListener("mousedown", () => { pressTimer = setTimeout(()=>clearTile(tile,row),500); });
    tile.addEventListener("mouseup", () => clearTimeout(pressTimer));

    row.appendChild(tile);
  }
  board.appendChild(row);
}

function clearTile(tile,row){
  tile.value = "";
  tile.dataset.state = "grey";
  tile.className = "tile grey";
  tile.focus();
  checkRowAndFilter(row);
}

/* ---------- Load Word Lists ---------- */
async function loadWords() {
  try {
    // URLs for raw text files
    const answersURL = "https://gist.githubusercontent.com/cfreshman/a03ef2cba789d8cf00c08f767e0fad7b/raw/wordle-answers-alphabetical.txt";
    const guessesURL = "https://gist.githubusercontent.com/cfreshman/a03ef2cba789d8cf00c08f767e0fad7b/raw/wordle-allowed-guesses.txt";

    // fetch answers + allowed guesses
    const [answersRes, guessesRes] = await Promise.all([fetch(answersURL), fetch(guessesURL)]);
    const answersText = await answersRes.text();
    const guessesText = await guessesRes.text();

    const answerList = answersText.split(/\r?\n/).map(w=>w.trim()).filter(Boolean);
    const guessList = guessesText.split(/\r?\n/).map(w=>w.trim()).filter(Boolean);

    // fetch past answers (to exclude)
    const pastURL = "https://gist.githubusercontent.com/cfreshman/a03ef2cba789d8cf00c08f767e0fad7b/raw/wordle-answers-alphabetical.txt";
    const pastRes = await fetch(pastURL);
    const pastText = await pastRes.text();
    const past = pastText.split(/\r?\n/).map(w=>w.trim()).filter(Boolean);
    const pastSet = new Set(past.map(w=>w.toLowerCase()));

    possibleWords = answerList.filter(w=>!pastSet.has(w));

    // allowedWords = guesses + answers
    allowedWords = Array.from(new Set([...guessList, ...answerList]));

    showResults(possibleWords,"Loaded");
    updateAnalysis(possibleWords);

  } catch(err){
    document.getElementById("results").innerText = "Error loading words: "+err;
  }
}
loadWords();

/* ---------- Filtering ---------- */
function countOccurrences(word,letter){ return [...word].filter(c=>c===letter).length; }

function applyFilters(){
  let filtered = possibleWords.slice();
  const rows = document.querySelectorAll(".grid");

  rows.forEach(row=>{
    const tiles = [...row.querySelectorAll(".tile")];
    const letters = tiles.map(t=>t.value.trim().toLowerCase());
    const states = tiles.map(t=>t.dataset.state);
    if (letters.every(l=>l==="")) return;

    const info = {};
    for(let i=0;i<WORD_LEN;i++){
      const L = letters[i]; if(!L) continue;
      if(!info[L]) info[L]={g:0,y:0,x:0};
      if(states[i]==="green") info[L].g++;
      else if(states[i]==="yellow") info[L].y++;
      else info[L].x++;
    }

    filtered = filtered.filter(w=>{
      for(let i=0;i<WORD_LEN;i++) if(states[i]==="green" && w[i]!==letters[i]) return false;
      for(let i=0;i<WORD_LEN;i++) if(states[i]==="yellow" && (w[i]===letters[i] || !w.includes(letters[i]))) return false;
      return true;
    });

    filtered = filtered.filter(w=>{
      for(const [L,c] of Object.entries(info)){
        const matched=c.g+c.y;
        const occ = countOccurrences(w,L);
        if(c.x>0 && matched===0 && occ!==0) return false;
        if(c.x>0 && matched>0 && occ!==matched) return false;
        if(c.x===0 && matched>0 && occ<matched) return false;
      }
      return true;
    });
  });

  showResults(filtered,"Filtered");
  updateAnalysis(filtered);
}

/* ---------- Analysis / Next Best Guess ---------- */
function analyzeRemainingWordle(filteredWords) {
  const totalWords = filteredWords.length;
  if(totalWords===0) return {letters:[], nextBest:"(none)"};

  const confirmed = {positions:{}};
  const rows = document.querySelectorAll('.grid');
  rows.forEach(row=>{
    const tiles = [...row.querySelectorAll('.tile')];
    tiles.forEach((tile,i)=>{
      const letter = tile.value.trim().toLowerCase();
      if(!letter) return;
      if(tile.dataset.state==='green'){
        confirmed.positions[letter] = confirmed.positions[letter]||[];
        if(!confirmed.positions[letter].includes(i)) confirmed.positions[letter].push(i
