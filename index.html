<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Wordle Solver with Next Best Guess</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; text-align: center; background: #fafafa; padding: 14px; }
.grid { display: grid; grid-template-columns: repeat(5, 56px); gap: 10px; margin: 12px auto; }
.tile { width: 56px; height: 56px; text-align: center; border: 2px solid #bbb; text-transform: uppercase; font-size: 26px; font-weight: 700; border-radius: 6px; padding: 0; box-sizing: border-box; caret-color: transparent; }
.grey { background: #cfcfcf; }
.yellow { background: #f2d36b; }
.green { background: #9ee29a; }
#controls { margin-top: 10px; }
#results, #analysis { margin-top: 16px; max-height: 300px; overflow-y: auto; text-align:left; white-space: pre-wrap; background: #fff; border: 1px solid #eee; padding: 10px; border-radius: 6px; }
button { padding: 8px 12px; font-size: 15px; margin: 4px; }
p.hint { font-size: 14px; color: #333; }
</style>
</head>
<body>
<h1>Wordle Solver</h1>
<p class="hint">Type guesses (auto-advance). Tap a filled tile to cycle colour. Long-press to clear. Filters auto-update when a row is complete.</p>

<div id="board" aria-label="Wordle input board"></div>
<div id="controls"><button onclick="resetBoard()">Reset board</button></div>
<div id="results"><em>Loading word list…</em></div>
<div id="analysis"></div>

<script>
const NUM_GUESSES=6;
const WORD_LEN=5;
let possibleWords=[];
let allowedWords=[];

/* ---------- Build UI ---------- */
const board=document.getElementById("board");
for(let r=0;r<NUM_GUESSES;r++){
  const row=document.createElement("div");
  row.className="grid";
  row.dataset.row=r;
  for(let c=0;c<WORD_LEN;c++){
    const tile=document.createElement("input");
    tile.className="tile grey";
    tile.maxLength=1;
    tile.inputMode="text";
    tile.autocomplete="off";
    tile.spellcheck=false;
    tile.dataset.state="grey";
    tile.dataset.col=c;
    tile.dataset.row=r;

    tile.addEventListener("input",(e)=>{
      tile.value=tile.value.toUpperCase();
      if(tile.value && c<WORD_LEN-1) row.children[c+1].focus();
      checkRowAndFilter(row);
    });
    tile.addEventListener("keydown",(e)=>{
      if(e.key==="Backspace"&&!tile.value && c>0) row.children[c-1].focus();
      else if(e.key==="Enter") applyFilters();
    });
    tile.addEventListener("click",(e)=>{
      if(tile.value){
        e.preventDefault();
        if(tile.dataset.state==="grey"){tile.dataset.state="yellow"; tile.className="tile yellow";}
        else if(tile.dataset.state==="yellow"){tile.dataset.state="green"; tile.className="tile green";}
        else {tile.dataset.state="grey"; tile.className="tile grey";}
        tile.blur();
        checkRowAndFilter(row);
      }
    });
    let pressTimer;
    tile.addEventListener("touchstart",()=>{pressTimer=setTimeout(()=>clearTile(tile,row),500);});
    tile.addEventListener("touchend",()=>clearTimeout(pressTimer));
    tile.addEventListener("mousedown",()=>{pressTimer=setTimeout(()=>clearTile(tile,row),500);});
    tile.addEventListener("mouseup",()=>clearTimeout(pressTimer));
    row.appendChild(tile);
  }
  board.appendChild(row);
}
function clearTile(tile,row){tile.value=""; tile.dataset.state="grey"; tile.className="tile grey"; tile.focus(); checkRowAndFilter(row);}

/* ---------- Load Words ---------- */
async function fetchTXT(url){const res=await fetch(url); return await res.text();}
async function loadWords(){
  try{
    // Answers from C. Freshman
    const answersTXT=await fetchTXT("https://gist.githubusercontent.com/cfreshman/a03ef2cba789d8cf00c08f767e0fad7b/raw/wordle-answers-alphabetical.txt");
    const answerWords=answersTXT.split(/\r?\n/).filter(w=>w.length===5).map(w=>w.toLowerCase());
    // Allowed guesses from C. Freshman
    const guessesTXT=await fetchTXT("https://gist.githubusercontent.com/cfreshman/0d4b62b8ccf37d20e5c3/raw/wordle-allowed-guesses.txt");
    const guessWords=guessesTXT.split(/\r?\n/).filter(w=>w.length===5).map(w=>w.toLowerCase());
    allowedWords=[...new Set([...guessWords,...answerWords])];

    // Past answers from RPS
    const pastTXT=await fetchTXT("https://www.rockpapershotgun.com/wordle-past-answers");
    const pastMatches=pastTXT.match(/\b[a-z]{5}\b/gi)||[];
    const pastSet=new Set(pastMatches.map(w=>w.toLowerCase()));

    possibleWords=answerWords.filter(w=>!pastSet.has(w));

    showResults(possibleWords,"Loaded");
    updateAnalysis(possibleWords);
  }catch(err){document.getElementById("results").innerText="Error loading words: "+err;}
}
loadWords();

/* ---------- Filtering ---------- */
function countOccurrences(word,letter){return [...word].filter(c=>c===letter).length;}
function applyFilters(){
  let filtered=possibleWords.slice();
  const rows=document.querySelectorAll(".grid");
  rows.forEach(row=>{
    const tiles=[...row.querySelectorAll(".tile")];
    const letters=tiles.map(t=>t.value.trim().toLowerCase());
    const states=tiles.map(t=>t.dataset.state);
    if(letters.every(l=>l==="")) return;
    const info={};
    for(let i=0;i<WORD_LEN;i++){const L=letters[i]; if(!L) continue; if(!info[L]) info[L]={g:0,y:0,x:0}; if(states[i]==="green") info[L].g++; else if(states[i]==="yellow") info[L].y++; else info[L].x++;}
    filtered=filtered.filter(w=>{
      for(let i=0;i<WORD_LEN;i++) if(states[i]==="green" && w[i]!==letters[i]) return false;
      for(let i=0;i<WORD_LEN;i++) if(states[i]==="yellow" && (w[i]===letters[i] || !w.includes(letters[i]))) return false;
      return true;
    });
    filtered=filtered.filter(w=>{
      for(const [L,c] of Object.entries(info)){
        const matched=c.g+c.y;
        const occ=countOccurrences(w,L);
        if(c.x>0 && matched===0 && occ!==0) return false;
        if(c.x>0 && matched>0 && occ!==matched) return false;
        if(c.x===0 && matched>0 && occ<matched) return false;
      }
      return true;
    });
  });
  showResults(filtered,"Filtered");
  updateAnalysis(filtered);
}

/* ---------- Analysis / Next Best Guess ---------- */
function analyzeRemainingWordle(filteredWords){
  const totalWords=filteredWords.length;
  if(totalWords===0) return {letters:[], nextBestElimination:"(none)", nextBestSolution:"(none)"};

  // Track yellow constraints
  const yellowInfo={};
  const rows=document.querySelectorAll(".grid");
  rows.forEach(row=>{
    const tiles=[...row.querySelectorAll(".tile")];
    tiles.forEach((tile,i)=>{
      const l=tile.value.trim().toLowerCase();
      if(!l || tile.dataset.state!=="yellow") return;
      yellowInfo[l]=yellowInfo[l]||new Set();
      yellowInfo[l].add(i);
    });
  });

  // letter frequency in remaining words
  const letterCounts={};
  for(const word of filteredWords){for(const ch of new Set(word)) letterCounts[ch]=(letterCounts[ch]||0)+1;}

  // elimination scoring: check allowedWords
  const wordScores=allowedWords.map(w=>{
    const uniqueLetters=[...new Set(w)];
    let score=0;
    for(const l of uniqueLetters){
      score+=letterCounts[l]||0;
      if(yellowInfo[l]){
        const wrongPos=yellowInfo[l];
        if(![...wrongPos].some(pos=>w[pos]===l)) score+=1; // bonus for yellow in valid spot
      }
    }
    return {word:w.toUpperCase(), score};
  });
  wordScores.sort((a,b)=>b.score-a.score);
  const nextBestElimination=wordScores[0]?.word || "(none)";

  // likely solution: pick best from filteredWords
  const nextBestSolution=filteredWords[0]?.toUpperCase() || "(none)";

  // letter probabilities
  const letters=[];
  for(const [l,count] of Object.entries(letterCounts)){
    const probability=Math.min((count/totalWords)*100,100);
    letters.push({letter:l.toUpperCase(), probability:probability.toFixed(1)});
  }
  letters.sort((a,b)=>b.probability-b.probability);
  return {letters, nextBestElimination, nextBestSolution};
}

function updateAnalysis(filteredWords){
  const analysis=analyzeRemainingWordle(filteredWords);
  let text=`Next best (elimination): ${analysis.nextBestElimination}\nNext best (likely solution): ${analysis.nextBestSolution}\n\nLetter probabilities:\n`;
  analysis.letters.forEach(l=>text+=`${l.letter}: ${l.probability}%\n`);
  document.getElementById("analysis").innerText=text;
}

/* ---------- Auto-filter ---------- */
function checkRowAndFilter(row){const filled=[...row.children].every(t=>t.value); if(filled) applyFilters();}

/* ---------- Reset ---------- */
function resetBoard(){
  document.querySelectorAll('.tile').forEach(t=>clearTile(t,t.parentElement));
  showResults(possibleWords,"Loaded");
  updateAnalysis(possibleWords);
}

function showResults(list,label){
  document.getElementById("results").innerText=`${label} (${list.length}):\n\n`+(list.length?list.slice(0,200).join(", ")+(list.length>200?" …":""):"(no matches)");
}
</script>
</body>
</html>
